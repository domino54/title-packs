// -------------------------------------- //
//  LIBRARY INTERFANCY by domino54        //
//  script version: 2017-03-04            //
// -------------------------------------- //

/**
 *	Works only in the title pack "GalaxyTitles@domino54".
 *	This library features a lot of custom interface replacement
 *	modules, which can be used in all game modes.
 *
 *	Available modules:
 *	- Gauges		Replaces gauges, moves chat and features reload boost indicator
 *	- ScoreSummary	Replaces score summary
 *	- Countdown		Replaces countdown timer
 *	- SpecInfo		Replaces spected player information box
 *	- Crosshair		Replaces crosshair, features also first bullet reload gauge and notices
 */

#Const	Version		"2017-03-04"
#Const	ScriptName	"Interfancy.Script.txt"

#Include "MathLib" as ML
#Include "TextLib" as TL
#Include "Libs/Nadeo/Layers2.Script.txt" as Layers
#Include "Libs/Nadeo/Manialink.Script.txt" as Manialink
#Include "Libs/domino54/ManialinkTools.Script.txt" as ManialinkTools
#Include "Libs/domino54/Translations.Script.txt" as Translations

// ---------------------------------- //
// Constants
// ---------------------------------- //
#Const C_ImgBase "file://Media/Manialinks/ShootMania/GalaxyTitles/"
#Const C_LibInterfancy_WidgetsRotation		2.
#Const C_LibInterfancy_NbGaugesInModel		10
#Const C_LibInterfancy_GaugeTotalLength		48.
#Const C_LibInterfancy_GaugeSpacingWidth	.5
#Const C_LibInterfancy_FrameHideawayPos		-16.
#Const C_LibInterfancy_GaugeSoundVolume		-10.
#Const C_LibInterfancy_NearMissDisplayTime	1000
#Const C_LibInterfancy_UICleaningPeriod		500

#Const C_LibInterfancy_ArmorPos			<-154., -84., 5.>
#Const C_LibInterfancy_StaminaPos		<0., -85., 5.>
#Const C_LibInterfancy_AmmunitionPos	<154., -84., 5.>
#Const C_LibInterfancy_ScoreSummaryPos	<0., 90., 5.>
#Const C_LibInterfancy_SpecInfoPos		<0., -68., 5.>
#Const C_LibInterfancy_CountdownPos		<0., 86.25, 5.>
#Const C_LibInterfancy_CrosshairPos		<0., 0., -5.>
#Const C_LibInterfancy_NearMissMsgPos	<0., -7.5, -4.>

// ---------------------------------- //
// Globales
// ---------------------------------- //
declare Text[]			G_LibInterfancy_ModulesLoaded;
declare Boolean[Text]	G_LibInterfancy_ModuleVisibility;
declare Vec3[Text]		G_LibInterfancy_ModulePosition;
declare Integer G_LibInterfancy_PrevStartTime;
declare Integer G_LibInterfancy_PrevEndTime;
declare Integer G_LibInterfancy_NextUICleaningTime;

// ---------------------------------- //
// Functions
// ---------------------------------- //

// ---------------------------------- //
// Private
// ---------------------------------- //

// ---------------------------------- //
/** Check if a module is loaded
 *
 *	@param	_ModuleId		The module to check
 *
 *	@return					True if the given module is loaded, False otherwise
 */
Boolean Private_ModuleIsLoaded(Text _ModuleId) {
	return G_LibInterfancy_ModulesLoaded.exists(_ModuleId);
}

// ---------------------------------- //
/** Update the settings for a module
 *
 *	@param	_Name		The name of the setting
 *	@param	_Value		The value of the setting
 */
Void Private_SetModuleSetting(Text _Name, Text _Value) {
	declare netwrite Net_LibInterfancy_SettingsUpdate for Teams[0] = 0;
	declare netwrite Net_LibInterfancy_Settings for Teams[0] = Text[Text];
	Net_LibInterfancy_SettingsUpdate = Now;
	Net_LibInterfancy_Settings[_Name] = _Value;
}

// ---------------------------------- //
/** Create universal gauge frame for modules
 *
 *	@return		The gauge frame manialink
 */
Text Private_CreateUnivarsalGaugeModel() {
	declare UniversalGaugeModel = "";
	for (I, 0, C_LibInterfancy_NbGaugesInModel - 1) UniversalGaugeModel ^= """
		<gauge sizen="0 8" valign="center" drawbg="0" drawblockbg="0" id="Gauge_Step#{{{I}}}" hidden="1"/>
	""";
	return UniversalGaugeModel;
}

// ---------------------------------- //
/** Create the gauges module manialink
 *
 *	@return		The gauges module manialink
 */
Text Private_CreateManialinkGauges() {
	return """
<manialink version="2" name="LibInterfancy:Gauges">
<stylesheet>
	<style class="count" valign="center2" textsize="3" textemboss="1" textcolor="FFF" textfont="Eurostile_Bold"/>
	<style class="desc" valign="center2" textsize="1" textemboss="1" textfont="Eurostile_Bold"/>
</stylesheet>

<frame id="Frame_HMDClip" clip="1" clipsizen="320 180">

<frame id="Frame_WidgetArmor" posn="{{{C_LibInterfancy_ArmorPos.X^" "^C_LibInterfancy_ArmorPos.Y + C_LibInterfancy_FrameHideawayPos^" "^C_LibInterfancy_ArmorPos.Z}}}" rot="{{{-C_LibInterfancy_WidgetsRotation}}}">
	<quad sizen="10 10" halign="center" valign="center" id="Quad_ModuleIcon"/>
	<quad sizen="10 10" halign="center" valign="center" id="Quad_ModuleIconGhost"/>
	
	<label posn="5 2.75" class="count" id="Label_ModuleCounter"/>
	<frame id="Frame_Gauge" posn="5">{{{Private_CreateUnivarsalGaugeModel()}}}</frame>
	
	<frame posn="5 -2.75">
		<label class="desc" id="Label_ModuleInfoText"/>
		<label class="desc" id="Label_ModuleInfoGhost"/>
	</frame>
</frame>

<frame id="Frame_WidgetStamina" posn="{{{C_LibInterfancy_StaminaPos.X^" "^C_LibInterfancy_StaminaPos.Y + C_LibInterfancy_FrameHideawayPos^" "^C_LibInterfancy_StaminaPos.Z}}}">
	<quad posn="0 5" sizen="10 10" halign="center" valign="center" id="Quad_ModuleIcon"/>
	<quad posn="0 5" sizen="10 10" halign="center" valign="center" id="Quad_ModuleIconGhost"/>
	
	<frame id="Frame_GaugeStamina" posn="{{{-C_LibInterfancy_GaugeTotalLength / 2}}}">
		{{{Private_CreateUnivarsalGaugeModel()}}}
	</frame>
	
	<frame posn="0 -2.75">
		<label halign="center" class="desc" id="Label_ModuleInfoText"/>
		<label halign="center" class="desc" id="Label_ModuleInfoGhost"/>
	</frame>
</frame>

<frame id="Frame_WidgetAmmo" posn="{{{C_LibInterfancy_AmmunitionPos.X^" "^C_LibInterfancy_AmmunitionPos.Y + C_LibInterfancy_FrameHideawayPos^" "^C_LibInterfancy_AmmunitionPos.Z}}}" rot="{{{C_LibInterfancy_WidgetsRotation}}}">
	<quad sizen="10 10" halign="center" valign="center" id="Quad_ModuleIcon"/>
	<quad sizen="10 10" halign="center" valign="center" id="Quad_ModuleIconGhost"/>
	
	<label posn="-5 2.75" halign="right" class="count" id="Label_ModuleCounter"/>
	<frame id="Frame_GaugeAmmo" posn="-5 -.35" rot="-180">{{{Private_CreateUnivarsalGaugeModel()}}}</frame>
	
	<frame posn="-5 -2.75">
		<label halign="right" class="desc" id="Label_ModuleInfoText"/>
		<label halign="right" class="desc" id="Label_ModuleInfoGhost"/>
	</frame>
	
	<frame posn="-40 -4"><frame id="Frame_ReloadBoost" posn="0 -8">
		<gauge posn="-1" sizen="24 8" halign="right" valign="center" drawbg="0" drawblockbg="0" ratio="1" id="Gauge_ReloadBoost"/>
		<quad sizen="5 5" halign="center" valign="center" image="{{{C_ImgBase}}}Icons/ReloadBoost.png" id="Quad_BoostIcon"/>
		<label posn="3" class="count" id="Label_BoostTimer"/>
	</frame></frame>
</frame>

</frame>

<script><!--
/**
 *	LibInterfancy: Gauges
 */

#Include "MathLib" as ML
#Include "TextLib" as TL

// ---------------------------------- //
// Constants
// ---------------------------------- //
#Const C_AvailableModules	["Armor", "Stamina", "Ammo"]
#Const C_WeaponsNames		[1 => "Laser", 2 => "Rocket", 3 => "Nucleus", 5 => "Arrow"]
#Const C_UIChatPosition		[False => <0., 0.>, True => <0., 0.05>]
#Const C_NbGaugesInModel	{{{C_LibInterfancy_NbGaugesInModel}}}
#Const C_FrameHideawayPos	{{{C_LibInterfancy_FrameHideawayPos}}}
#Const C_GaugeTotalLength	{{{C_LibInterfancy_GaugeTotalLength}}}
#Const C_GaugeSpacingWidth	{{{C_LibInterfancy_GaugeSpacingWidth}}}
#Const C_GaugeSoundVolume	{{{C_LibInterfancy_GaugeSoundVolume}}}
#Const C_GaugePositionFix	4.
#Const C_StaminaDisplayTime	1500

/// Icons of the modules
#Const C_ModulesIcons [
	"Armor"		=> "{{{C_ImgBase}}}Icons/Armor.png",
	"Laser"		=> "{{{C_ImgBase}}}Icons/Laser.png",
	"Rocket"	=> "{{{C_ImgBase}}}Icons/Rocket.png",
	"Nucleus"	=> "{{{C_ImgBase}}}Icons/Nucleus.png",
	"Arrow"		=> "{{{C_ImgBase}}}Icons/Arrow.png",
	"Stamina"	=> "{{{C_ImgBase}}}Icons/Jump.png",
	"Sprint"	=> "{{{C_ImgBase}}}Icons/Run.png"
]

#Const C_ModulesSounds [
	"AmmoStep"		=> "{{{C_ImgBase}}}SoundGauge/UIGaugeEnergyBallSlot.wav",
	"ArmorStep"		=> "{{{C_ImgBase}}}SoundGauge/UIGaugeHealthGradFull.wav",
	"StaminaFull"	=> "{{{C_ImgBase}}}SoundGauge/UIGaugeStaminaFull.wav",
	"StaminaEmpty"	=> "{{{C_ImgBase}}}SoundGauge/UIGaugeStaminaEmpty.wav"
]

// ---------------------------------- //
// Global variables
// ---------------------------------- //
declare CMlGauge[][Text] G_Gauges;
declare Text[Text] G_ModulesIcons;

// ---------------------------------- //
// Main
// ---------------------------------- //
***Main***
***
// ---------------------------------- //
// Load interface elements
declare Frame_ReloadBoost	<=> (Page.GetFirstChild("Frame_ReloadBoost") as CMlFrame);
declare Gauge_ReloadBoost	<=> (Page.GetFirstChild("Gauge_ReloadBoost") as CMlGauge);
declare Label_BoostTimer	<=> (Page.GetFirstChild("Label_BoostTimer") as CMlLabel);
declare Quad_BoostIcon		<=> (Page.GetFirstChild("Quad_BoostIcon") as CMlQuad);

declare CMlFrame[Text] Frame_Widget;
declare CMlLabel[Text] Label_ModuleCounter;
declare CMlLabel[Text] Label_ModuleInfoText;
declare CMlLabel[Text] Label_ModuleInfoGhost;
declare CMlQuad[Text] Quad_ModuleIcon;
declare CMlQuad[Text] Quad_ModuleIconGhost;

foreach (Module in C_AvailableModules) {
	Frame_Widget[Module] = (Page.GetFirstChild("Frame_Widget"^Module) as CMlFrame);
	declare Frame = Frame_Widget[Module];
	
	Label_ModuleCounter[Module] = (Frame.GetFirstChild("Label_ModuleCounter") as CMlLabel);
	Label_ModuleInfoText[Module] = (Frame.GetFirstChild("Label_ModuleInfoText") as CMlLabel);
	Label_ModuleInfoGhost[Module] = (Frame.GetFirstChild("Label_ModuleInfoGhost") as CMlLabel);
	Quad_ModuleIcon[Module] = (Frame.GetFirstChild("Quad_ModuleIcon") as CMlQuad);
	Quad_ModuleIconGhost[Module] = (Frame.GetFirstChild("Quad_ModuleIconGhost") as CMlQuad);
	
	// ---------------------------------- //
	// Load gauge modules
	G_Gauges[Module] = CMlGauge[];
	for (I, 0, C_NbGaugesInModel - 1) G_Gauges[Module].add((Frame.GetFirstChild("Gauge_Step#"^I) as CMlGauge));
}

// ---------------------------------- //
// Persistent settings
declare persistent Persistent_LibInterfancy_AlwaysShowStamina for LocalUser = False;

// ---------------------------------- //
// Netcode
declare netread Integer Net_LibInterfancy_SettingsUpdate for Teams[0];
declare netread Text[Text] Net_LibInterfancy_Settings for Teams[0];
declare netread Int3[Text] Net_LibInterfancy_ReloadData for Teams[0];

/// Players colors
declare netread Vec3[Text] Net_LibInterfancy_ForcedColors for Teams[0];

/// Custom weapons
declare netread Text[Text] Net_LibInterfancy_PlayersWeaponsNames for Teams[0];

// ---------------------------------- //
// Variables
declare Gauges_Display = True;
declare DisplayArmor = True;
declare DisplayAmmo = True;
declare DisplayStamina = True;

declare InterfaceColor = <1., 1., 1.>;
declare StaminaDisplayEndTime = -1;
declare Integer[Text] PlayerIsOnTechArmor;
declare ShowReloadBoost = False;
declare GUIPlayerClan = 0;

declare Boolean[Text] FrameVisible;
declare Real[Text] ModuleRatio;
declare Integer[Text] ModuleSlots;
declare Text[Text] ModuleInfoText;
declare Text[Text] ModuleIcon;

/// Update
declare PrevGauges_Display = False;
declare PrevGUIPlayerLogin = "";
declare PrevGUIPlayerCurWeapon = 0;
declare PrevGUIPlayerClan = 0;
declare PrevGUIPlayerUserColor = Vec3;
declare PrevGUIPlayerForcedColor = Vec3;
declare PrevInterfaceColor = Vec3;
declare PrevShowReloadBoost = False;

declare Boolean[Text] PrevFrameVisible;
declare Real[Text] PrevModuleRatio;
declare Integer[Text] PrevModuleSlots;
declare Text[Text] PrevModuleInfoText;
declare Text[Text] PrevModuleIcon;

declare PrevSettingsUpdate = -1;

G_ModulesIcons = C_ModulesIcons;
ModuleIcon["Armor"] = G_ModulesIcons["Armor"];
ModuleSlots["Stamina"] = 1;
***

// ---------------------------------- //
// Yield
// ---------------------------------- //
***Yield***
***
// ---------------------------------- //
// Update settings
if (PrevSettingsUpdate != Net_LibInterfancy_SettingsUpdate) {
	PrevSettingsUpdate = Net_LibInterfancy_SettingsUpdate;
	
	foreach (SettingName => SettingValue in Net_LibInterfancy_Settings) {
		switch (SettingName) {
			case "Gauges_Display"	: Gauges_Display	= SettingValue == "True";
			case "Armor_Display"	: DisplayArmor		= SettingValue == "True";
			case "Ammo_Display"		: DisplayAmmo		= SettingValue == "True";
			case "Stamina_Display"	: DisplayStamina	= SettingValue == "True";
			default : {
				if (TL::SubString(SettingName, 0, 11) == "Gauges_Icon" && SettingValue != "") {
					declare IconId = TL::Replace(SettingName, "Gauges_Icon", "");
					G_ModulesIcons[IconId] = SettingValue;
					PrevModuleIcon.clear();
				}
			}
		}
	}
}

// ---------------------------------- //
// Get the interface color from the player
if (GUIPlayer != Null) {
	if (GUIPlayer.CurrentClan != GUIPlayerClan) GUIPlayerClan = GUIPlayer.CurrentClan;
	
	if (GUIPlayerClan == 0) {
		// ---------------------------------- //
		// Use the player's forced color
		if (Net_LibInterfancy_ForcedColors.existskey(GUIPlayer.User.Login)) {
			if (Net_LibInterfancy_ForcedColors[GUIPlayer.User.Login] != PrevGUIPlayerForcedColor) {
				PrevGUIPlayerForcedColor = Net_LibInterfancy_ForcedColors[GUIPlayer.User.Login];
				InterfaceColor = PrevGUIPlayerForcedColor;
			}
		}
		// ---------------------------------- //
		// Uer player's profile color
		else if (PrevGUIPlayerUserColor != GUIPlayer.User.Color) {
			PrevGUIPlayerUserColor = GUIPlayer.User.Color;
			InterfaceColor = PrevGUIPlayerUserColor;
		}
	}
}

// ---------------------------------- //
// Update color on player clan change
if (PrevGUIPlayerClan != GUIPlayerClan) {
	PrevGUIPlayerClan = GUIPlayerClan;
	if (Teams.existskey(GUIPlayerClan - 1)) InterfaceColor = Teams[GUIPlayerClan - 1].ColorPrimary;
}

// ---------------------------------- //
// Set interface colour
if (PrevInterfaceColor != InterfaceColor) {
	PrevInterfaceColor = InterfaceColor;
	
	foreach (Module in C_AvailableModules) {
		foreach (Gauge in G_Gauges[Module]) Gauge.Color = InterfaceColor;
		declare BrightTextColor = Brightness(InterfaceColor, 4.);
		Label_ModuleInfoText[Module].TextColor = BrightTextColor;
		Label_ModuleInfoGhost[Module].TextColor = BrightTextColor;
	}
	
	Gauge_ReloadBoost.Color = InterfaceColor;
}

// Hide full stamina bar after some delay
if (GUIPlayer != Null && GUIPlayer.Stamina < GUIPlayer.StaminaMax * 3600) StaminaDisplayEndTime = Now + C_StaminaDisplayTime;

// ---------------------------------- //
// Set the chat offset
if (PrevGauges_Display != Gauges_Display) {
	PrevGauges_Display = Gauges_Display;
	
	ClientUI.OverlayChatOffset = C_UIChatPosition[Gauges_Display];
	ClientUI.OverlayChatHideAvatar = Gauges_Display;
}

// ---------------------------------- //
// Get for how long players are loading their armor
foreach (Player in Players) {
	if (Player.RequestsSpectate || Player.IsBot || Player.SpawnStatus != CSmPlayer::ESpawnStatus::Spawned) continue;
	
	if (Player.IsOnTechArmor) {
		if (!PlayerIsOnTechArmor.existskey(Player.User.Login)) PlayerIsOnTechArmor[Player.User.Login] = GameTime;
	}
	else if (PlayerIsOnTechArmor.existskey(Player.User.Login)) {
		declare Removed = PlayerIsOnTechArmor.removekey(Player.User.Login);
	}
}

// ---------------------------------- //
// Manage modules
foreach (Module in C_AvailableModules) {
	// ---------------------------------- //
	// Update module visibility
	declare ShowModule = False;
	switch (Module) {
		case "Armor" : ShowModule = GUIPlayer != Null && DisplayArmor && GUIPlayer.ArmorMax > 0;
		case "Stamina" : ShowModule = GUIPlayer != Null && DisplayStamina && !GUIPlayer.IsOnTechNoWeapon && (Now < StaminaDisplayEndTime || Persistent_LibInterfancy_AlwaysShowStamina);
		case "Ammo" : ShowModule = GUIPlayer != Null && DisplayAmmo && GUIPlayer.CurAmmoMax > 0 && GUIPlayer.CurAmmoUnit > 0 && !GUIPlayer.IsOnTechNoWeapon;
	}
	
	FrameVisible[Module] = UI.OverlayHideGauges && Gauges_Display && GUIPlayer != Null && GUIPlayer.Position != <0., 0., 0.> && ShowModule;
	
	// ---------------------------------- //
	// Set module visibility
	if (!PrevFrameVisible.existskey(Module) || PrevFrameVisible[Module] != FrameVisible[Module]) {
		PrevFrameVisible[Module] = FrameVisible[Module];
		
		declare Easing = "EaseOutBack";
		declare Real PosY;
		
		switch (Module) {
			case "Armor"	: PosY = {{{C_LibInterfancy_ArmorPos.Y}}};
			case "Stamina"	: PosY = {{{C_LibInterfancy_StaminaPos.Y}}};
			case "Ammo"		: PosY = {{{C_LibInterfancy_AmmunitionPos.Y}}};
		}
		
		if (!FrameVisible[Module]) {
			PrevModuleRatio[Module] = -1.;
			Easing = "EaseInCirc";
			PosY += C_FrameHideawayPos;
		}
		
		LibManialink_AnimStop(Frame_Widget[Module]);
		declare Position = Frame_Widget[Module].RelativePosition.X^" "^PosY^" "^Frame_Widget[Module].RelativePosition.Z;
		LibManialink_Anim(Frame_Widget[Module], "<frame posn='"^Position^"'/>", 200, Easing);
	}
	
	if (!FrameVisible[Module]) continue;
	
	switch (Module) {
		// ---------------------------------- //
		// Armor module
		case "Armor" : {
			declare GUIPlayerArmorLoaded = 0.;
			if (PlayerIsOnTechArmor.existskey(GUIPlayer.User.Login))
				GUIPlayerArmorLoaded = (GameTime - PlayerIsOnTechArmor[GUIPlayer.User.Login]) % 1850 / 1850.;
			
			ModuleRatio[Module] = GUIPlayer.Armor / 100. + GUIPlayerArmorLoaded;
			ModuleSlots[Module] = GUIPlayer.ArmorMax / 100;
			
			if (GUIPlayer.IsOnTechArmor) {
				if (GUIPlayer.Armor < GUIPlayer.ArmorMax) ModuleInfoText[Module] = "Healing...";
				else ModuleInfoText[Module] = "Healing Pad";
			}
			else if (GUIPlayer.IsOnTechLaser)
				ModuleInfoText[Module] = "Zoom Pad";
			else if (GUIPlayer.IsOnTechArrow)
				ModuleInfoText[Module] = "Arrow Pad";
			else if (GUIPlayer.IsOnTechSafeZone)
				ModuleInfoText[Module] = "Safe Zone";
			else if (GUIPlayer.IsUnderground)
				ModuleInfoText[Module] = "Tunnels";
			else
				ModuleInfoText[Module] = "Armor";
		}
		// ---------------------------------- //
		// Stamina module
		case "Stamina" : {
			ModuleRatio[Module] = (GUIPlayer.Stamina / 3600.) / GUIPlayer.StaminaMax;
			
			if (GUIPlayer.IsOnTech) {
				ModuleInfoText[Module] = "Sprint Path";
				ModuleIcon[Module] = G_ModulesIcons["Sprint"];
			} else {
				ModuleInfoText[Module] = "Stamina";
				ModuleIcon[Module] = G_ModulesIcons["Stamina"];
			}
		}
		// ---------------------------------- //
		// Ammunition module
		case "Ammo" : {
			ModuleRatio[Module] = ML::ToReal(GUIPlayer.CurAmmo) / GUIPlayer.CurAmmoUnit;
			ModuleSlots[Module] = GUIPlayer.CurAmmoMax / GUIPlayer.CurAmmoUnit;
			
			// ---------------------------------- //
			// Display name and icon of a custom weapon
			if (
				Net_LibInterfancy_PlayersWeaponsNames.existskey(GUIPlayer.User.Login) &&
				Net_LibInterfancy_PlayersWeaponsNames[GUIPlayer.User.Login] != ""
			) {
				declare WeaponName = Net_LibInterfancy_PlayersWeaponsNames[GUIPlayer.User.Login];
				ModuleInfoText[Module] = WeaponName;
				if (G_ModulesIcons.existskey(WeaponName)) ModuleIcon[Module] = G_ModulesIcons[WeaponName];
			}
			// ---------------------------------- //
			// Display name and icon of a default weapon
			else if (C_WeaponsNames.existskey(GUIPlayer.CurWeapon)) {
				ModuleInfoText[Module] = C_WeaponsNames[GUIPlayer.CurWeapon];
				ModuleIcon[Module] = G_ModulesIcons[C_WeaponsNames[GUIPlayer.CurWeapon]];
			}
			// ---------------------------------- //
			// Display default name and icon, if something went wrong
			else {
				ModuleInfoText[Module] = "Weapon";
				ModuleIcon[Module] = G_ModulesIcons[C_WeaponsNames[2]];
			}
		}
	}
	
	// ---------------------------------- //
	// Update gauges ratio
	if (
		!PrevModuleRatio.existskey(Module) || !PrevModuleSlots.existskey(Module) ||
		PrevModuleRatio[Module] != ModuleRatio[Module] ||
		PrevModuleSlots[Module] != ModuleSlots[Module]
	) {
		SetModuleRatio(Module, ModuleRatio[Module], ModuleSlots[Module]);
		
		if (Module != "Stamina")
			Label_ModuleCounter[Module].Value = ML::FloorInteger(ModuleRatio[Module])^"$777/"^ModuleSlots[Module];
		
		// ---------------------------------- //
		// Play the interface sounds
		if (PrevGUIPlayerLogin == GUIPlayer.User.Login && PrevModuleRatio.existskey(Module) && PrevModuleRatio[Module] > -1) {
			if (ML::FloorInteger(ModuleRatio[Module]) > PrevModuleRatio[Module]) {
				switch (Module) {
					// ---------------------------------- //
					// Armor loaded
					case "Armor" : {
						if (GUIPlayer.SpawnStatus == CSmPlayer::ESpawnStatus::Spawned)
							Audio.PlaySoundEvent(C_ModulesSounds["ArmorStep"], C_GaugeSoundVolume);
					}
					// ---------------------------------- //
					// Weapon loaded
					case "Ammo" : {
						if (PrevGUIPlayerCurWeapon == GUIPlayer.CurWeapon)
							Audio.PlaySoundEvent(C_ModulesSounds["AmmoStep"], C_GaugeSoundVolume);
						
						else PrevGUIPlayerCurWeapon = GUIPlayer.CurWeapon;
					}
					// ---------------------------------- //
					// Stamina loaded
					case "Stamina" : Audio.PlaySoundEvent(C_ModulesSounds["StaminaFull"], C_GaugeSoundVolume);
				}
			}
			
			if (Module == "Stamina" && ModuleRatio[Module] <= 0 && PrevModuleRatio[Module] > 0)
				Audio.PlaySoundEvent(C_ModulesSounds["StaminaEmpty"], C_GaugeSoundVolume);
		}
		
		PrevModuleRatio[Module] = ModuleRatio[Module];
		PrevModuleSlots[Module] = ModuleSlots[Module];
	}
	
	// ---------------------------------- //
	// Update module information text
	if (!PrevModuleInfoText.existskey(Module) || PrevModuleInfoText[Module] != ModuleInfoText[Module]) {
		Label_ModuleInfoText[Module].SetText("$t"^Translate(ModuleInfoText[Module]));
		if (PrevModuleInfoText.existskey(Module))
			Label_ModuleInfoGhost[Module].SetText("$t"^Translate(PrevModuleInfoText[Module]));
			
		LibManialink_AnimStop(Label_ModuleInfoText[Module]);
		LibManialink_AnimStop(Label_ModuleInfoGhost[Module]);
		
		Label_ModuleInfoText[Module].Opacity = 0.;
		Label_ModuleInfoText[Module].RelativePosition.Y = 1.5;
		Label_ModuleInfoGhost[Module].Opacity = 1.;
		Label_ModuleInfoGhost[Module].RelativePosition.Y = 0.;
		
		LibManialink_Anim(Label_ModuleInfoText[Module], "<label posn='0 0' opacity=1 />", 200, "EaseLinear");
		LibManialink_Anim(Label_ModuleInfoGhost[Module], "<label posn='0 -1.5' opacity=0 />", 200, "EaseLinear");
		PrevModuleInfoText[Module] = ModuleInfoText[Module];
	}
	
	// ---------------------------------- //
	// Update module icon
	if (!PrevModuleIcon.existskey(Module) || PrevModuleIcon[Module] != ModuleIcon[Module]) {
		SetIconImage(Quad_ModuleIcon[Module], ModuleIcon[Module]);
		if (PrevModuleIcon.existskey(Module)) SetIconImage(Quad_ModuleIconGhost[Module], PrevModuleIcon[Module]);
		
		LibManialink_AnimStop(Quad_ModuleIcon[Module]);
		LibManialink_AnimStop(Quad_ModuleIconGhost[Module]);
		
		Quad_ModuleIcon[Module].Opacity = 0.;
		Quad_ModuleIconGhost[Module].Opacity = 1.;
		
		LibManialink_Anim(Quad_ModuleIcon[Module], "<quad opacity=1 />", 125, "EaseLinear");
		LibManialink_Anim(Quad_ModuleIconGhost[Module], "<quad opacity=0 />", 125, "EaseLinear");
		PrevModuleIcon[Module] = ModuleIcon[Module];
	}
}

// ---------------------------------- //
// Reload boost
ShowReloadBoost = (
	GUIPlayer != Null && Net_LibInterfancy_ReloadData.existskey(GUIPlayer.User.Login) &&
	GameTime <= Net_LibInterfancy_ReloadData[GUIPlayer.User.Login].X + Net_LibInterfancy_ReloadData[GUIPlayer.User.Login].Y
);

// ---------------------------------- //
// Relaod boost animation
if (PrevShowReloadBoost != ShowReloadBoost) {
	PrevShowReloadBoost = ShowReloadBoost;
	
	declare Easing = "EaseOutBack";
	declare Real PosY;
	
	if (!ShowReloadBoost) {
		Label_BoostTimer.SetText("0");
		Gauge_ReloadBoost.Size.X = 0.;
		Easing = "EaseInCirc";
		PosY -= 8.;
	}
	
	LibManialink_AnimStop(Frame_ReloadBoost);
	declare Position = Frame_ReloadBoost.RelativePosition.X^" "^PosY^" "^Frame_ReloadBoost.RelativePosition.Z;
	LibManialink_Anim(Frame_ReloadBoost, "<frame posn='"^Position^"'/>", 200, Easing);
}

// ---------------------------------- //
// Setup boost gauge
if (ShowReloadBoost) {
	declare BoostStartTime = Net_LibInterfancy_ReloadData[GUIPlayer.User.Login].X;
	declare BoostDuration = Net_LibInterfancy_ReloadData[GUIPlayer.User.Login].Y;
	Gauge_ReloadBoost.Size.X = 20 * (1. - ML::ToReal(GameTime - BoostStartTime) / BoostDuration) + 4.;
	Label_BoostTimer.Value = TL::ToText((BoostStartTime + BoostDuration - GameTime) / 1000 + 1);
}

// Update player
if (GUIPlayer != Null) {
	if (PrevGUIPlayerLogin != GUIPlayer.User.Login) PrevGUIPlayerLogin = GUIPlayer.User.Login;
	if (PrevGUIPlayerCurWeapon != GUIPlayer.CurWeapon) PrevGUIPlayerCurWeapon = GUIPlayer.CurWeapon;
}
***

// ---------------------------------- //
// Functions
// ---------------------------------- //

{{{ManialinkTools::Functions(["SetGaugeRatio", "Brightness"])}}}

// ---------------------------------- //
/** Set icon image of the Quad
 *
 *	@param	_Quad		The Quad to set image
 *	@param	_Image		Image to set
 */
Void SetIconImage(CMlQuad _Quad, Text _Image) {
	if (_Quad == Null) return;
	_Quad.ImageUrl = "";
	_Quad.Style = "";
	_Quad.Substyle = "";
	if (_Image == "") return;
	
	declare ManiaStylePath = TL::Split("|", _Image);
	if (ManiaStylePath.count == 2) {
		_Quad.Style = ManiaStylePath[0];
		_Quad.Substyle = ManiaStylePath[1];
	}
	else _Quad.ImageUrl = _Image;
}

// ---------------------------------- //
/** Set module value
 *
 *	@param	_Module		Module to set energy
 *	@param	_Energy		Amount of currently loaded energy
 *	@param	_Slots		Amount of available energy slots
 */
Void SetModuleRatio(Text _Module, Real _Energy, Integer _Slots) {
	if (!G_Gauges.existskey(_Module)) return;
	declare persistent Persistent_LibInterfancy_ShowGaugesBgs for LocalUser = False;
	declare Gauges = G_Gauges[_Module];
	
	// ---------------------------------- //
	// Hide gauges if there are no slots
	if (_Slots <= 0) {
		foreach (Gauge in Gauges) Gauge.Visible = False;
		
		// There is nothing more to do without slots
		return;
	}
	// ---------------------------------- //
	// Adjust up to N gauges for slots
	else if (_Slots <= Gauges.count) {
		declare SpacingSizeSub = 0.;
		if (_Slots >= 2) SpacingSizeSub = C_GaugeSpacingWidth * (_Slots - 1) / _Slots;
		declare GaugeSlotSize = C_GaugeTotalLength / _Slots + C_GaugePositionFix - SpacingSizeSub;
		
		foreach (I => Gauge in Gauges) {
			Gauge.Visible = I <= _Slots - 1;
			if (!Gauge.Visible) continue;
			
			Gauge.Size.X = GaugeSlotSize;
			Gauge.RelativePosition.X = (GaugeSlotSize - C_GaugePositionFix) * I - C_GaugePositionFix / 2;
			Gauge.DrawBlockBackground = Persistent_LibInterfancy_ShowGaugesBgs;
			if (I > 0) Gauge.RelativePosition.X += C_GaugeSpacingWidth * I;
		}
	}
	// ---------------------------------- //
	// Use one gauge for over N slots
	else {
		foreach (I => Gauge in Gauges) {
			Gauge.Visible = I == 0;
			if (!Gauge.Visible) continue;
			
			Gauge.Size.X = C_GaugeTotalLength + C_GaugePositionFix;
			Gauge.RelativePosition.X = -C_GaugePositionFix / 2;
		}
	}
	
	// ---------------------------------- //
	// Set gauges ratios
	foreach (I => Gauge in Gauges) {
		if (!Gauge.Visible) continue;
		// Gauge.DrawBlockBackground = _Module == "Stamina";
		
		// ---------------------------------- //
		// Format ratios for gauges until N slots
		if (_Slots <= C_NbGaugesInModel) SetGaugeRatio(Gauge, _Energy - I);
		
		// ---------------------------------- //
		// Format ratio for gauge above N slots
		else SetGaugeRatio(Gauge, _Energy / _Slots);
	}
}

{{{Manialink::Animations(["EaseInOutSine", "EaseInCirc", "EaseOutBack"])}}}
{{{Translations::InjectInManialink(["Laser", "Nucleus", "Arrow", "Rocket", "Stamina", "Sprint Path", "Armor", "Healing Pad", "Healing...", "Zoom Pad", "Arrow Pad", "Safe Zone", "Tunnels", "Handheld Charge", "Frozen Arrow", "Plasma Grenade", "Torpede", "Wide Rail"])}}}

// ---------------------------------- //
// Main
// ---------------------------------- //
main() {
	+++Main+++
	while (True) {
		+++Yield+++
		LibManialink_AnimLoop();
		yield;
	}
}
--></script>
</manialink>""";
}

// ---------------------------------- //
/** Create the manialink for the score summary module.
 *
 *	@return		The score summary manialink.
 */
Text Private_CreateManialinkScoreSummary() {
	return """
<manialink version="2" name="LibInterfancy:ScoreSummary">
<stylesheet>
	<style class="bg" sizen="30 10" colorize="777"/>
	<style class="font" textsize="4" textfont="Eurostile_Bold" textemboss="1" textcolor="FFF"/>
</stylesheet>

<frame id="Frame_ScoreSummary" posn="{{{C_LibInterfancy_ScoreSummaryPos.X^" "^C_LibInterfancy_ScoreSummaryPos.Y + 15^" "^C_LibInterfancy_ScoreSummaryPos.Z}}}">
	<quad posn="-10" class="bg" image="{{{C_ImgBase}}}UiScoreSummaryLeft.png" halign="right" id="Quad_SummaryBgLeft"/>
	<label posn="-13 -3" valign="center2" class="font" text="0" halign="right" id="Label_SummaryPtsLeft"/>
	<label posn="-13 -7" valign="center2" class="font" textsize="2" halign="right" id="Label_SummaryRoundLeft" hidden="1"/>
	
	<quad posn="10" class="bg" image="{{{C_ImgBase}}}UiScoreSummaryRight.png" id="Quad_SummaryBgRight"/>
	<label posn="13 -3" valign="center2" class="font" text="0" id="Label_SummaryPtsRight"/>
	<label posn="13 -7" valign="center2" class="font" textsize="2" id="Label_SummaryRoundRight" hidden="1"/>
</frame>

<script><!--
/**
 *	LibInterfancy: ScoreSummary
 */

#Include "MathLib" as ML
#Include "TextLib" as TL

#Const C_FrameHideaway	15.

// ---------------------------------- //
// Main
// ---------------------------------- //
***Main***
***
// ---------------------------------- //
// Load interface elements
declare Frame_ScoreSummary		<=> (Page.GetFirstChild("Frame_ScoreSummary")		as CMlFrame);
declare Quad_SummaryBgLeft		<=> (Page.GetFirstChild("Quad_SummaryBgLeft")		as CMlQuad);
declare Quad_SummaryBgRight		<=> (Page.GetFirstChild("Quad_SummaryBgRight")		as CMlQuad);
declare Label_SummaryPtsLeft	<=> (Page.GetFirstChild("Label_SummaryPtsLeft")		as CMlLabel);
declare Label_SummaryPtsRight	<=> (Page.GetFirstChild("Label_SummaryPtsRight")	as CMlLabel);
declare Label_SummaryRoundLeft	<=> (Page.GetFirstChild("Label_SummaryRoundLeft")	as CMlLabel);
declare Label_SummaryRoundRight	<=> (Page.GetFirstChild("Label_SummaryRoundRight")	as CMlLabel);

// ---------------------------------- //
// Netcode
declare netread Integer Net_LibInterfancy_SettingsUpdate for Teams[0];
declare netread Text[Text] Net_LibInterfancy_Settings for Teams[0];

// ---------------------------------- //
// Variables
declare ScoreSummary_Display = False;
declare ShowScoreSummary = False;
declare ShowRoundPoints = False;
declare ClanRoundScores = [1 => 0, 2 => 0];

declare PrevSettingsUpdate = -1;
declare PrevShowScoreSummary = False;
declare PrevTeamsColors = [0 => Vec3, 1 => Vec3];
declare PrevClanScores = Integer[Integer];
declare PrevClanRoundScores = Integer[Integer];
declare PrevShowRoundPoints = False;
***

// ---------------------------------- //
// Yield
// ---------------------------------- //
***Yield***
***
// ---------------------------------- //
// Update settings
if (PrevSettingsUpdate != Net_LibInterfancy_SettingsUpdate) {
	PrevSettingsUpdate = Net_LibInterfancy_SettingsUpdate;
	
	foreach (SettingName => SettingValue in Net_LibInterfancy_Settings) {
		switch (SettingName) {
			case "ScoreSummary_Display" : ScoreSummary_Display = SettingValue == "True";
			case "ScoreSummary_ShowRoundPoints" : ShowRoundPoints = SettingValue == "True";
		}
	}
}

ShowScoreSummary = ScoreSummary_Display && UseClans;

// ---------------------------------- //
// Set score summary visibility
if (PrevShowScoreSummary != ShowScoreSummary) {
	PrevShowScoreSummary = ShowScoreSummary;
	
	declare TargetPosition = Frame_ScoreSummary.RelativePosition;
	TargetPosition.Y = {{{C_LibInterfancy_ScoreSummaryPos.Y}}};
	declare TargetEasing = "EaseOutCirc";
	
	if (!ShowScoreSummary) {
		TargetPosition.Y += C_FrameHideaway;
		TargetEasing = "EaseInCirc";
	}
	
	LibManialink_Anim(
		"<frame id='Frame_ScoreSummary' posn='"^TargetPosition.X^" "^TargetPosition.Y^" "^TargetPosition.Z^"'/>",
		250, TargetEasing
	);
}

if (!ShowScoreSummary) continue;

// ---------------------------------- //
//Set round points visibility
if (PrevShowRoundPoints != ShowRoundPoints) {
	PrevShowRoundPoints = ShowRoundPoints;
	
	Label_SummaryRoundLeft.Visible = ShowRoundPoints;
	Label_SummaryRoundRight.Visible = ShowRoundPoints;
}

ClanRoundScores = [1 => UI.ScoreSummary_RoundPoints1, 2 => UI.ScoreSummary_RoundPoints2];

// ---------------------------------- //
// Update teams colors
foreach (TeamId => Team in Teams) {
	if (PrevTeamsColors[TeamId] == Team.ColorPrimary) continue;
	PrevTeamsColors[TeamId] = Team.ColorPrimary;

	LibManialink_AnimStop(Quad_SummaryBgLeft);
	LibManialink_AnimStop(Quad_SummaryBgRight);
	
	Quad_SummaryBgLeft.Colorize = Brightness(Teams[0].ColorPrimary, 1.5);
	Quad_SummaryBgRight.Colorize = Brightness(Teams[1].ColorPrimary, 1.5);
}

// ---------------------------------- //
// Update clans scores
for (Clan, 1, 2) {
	// ---------------------------------- //
	// Set match scores
	if (
		ClanScores.existskey(Clan) && (!PrevClanScores.existskey(Clan) ||
		PrevClanScores[Clan] != ClanScores[Clan])
	) {
		PrevClanScores[Clan] = ClanScores[Clan];
		
		declare CMlLabel Label;
		declare CMlQuad Quad;
		
		switch (Clan) {
			case 1 : {
				Label = Label_SummaryPtsLeft;
				Quad = Quad_SummaryBgLeft;
			}
			case 2 : {
				Label = Label_SummaryPtsRight;
				Quad = Quad_SummaryBgRight;
			}
		}
		
		if (Label != Null) Label.SetText(TL::ToText(ClanScores[Clan]));
		
		if (Quad != Null) {
			Quad.Colorize = <1., 1., 1.>;
			declare TargetColor = TL::ColorToText(Brightness(Teams[Clan - 1].ColorPrimary, 1.5));
			LibManialink_Anim(Quad, "<quad colorize='"^TargetColor^"'/>", 250, "EaseLinear");
		}
	}
	
	// ---------------------------------- //
	// Set round scores
	if (
		ClanRoundScores.existskey(Clan) &&
		(!PrevClanRoundScores.existskey(Clan) || PrevClanRoundScores[Clan] != ClanRoundScores[Clan])
	) {
		PrevClanRoundScores[Clan] = ClanRoundScores[Clan];
		
		declare CMlLabel Label;
		switch (Clan) {
			case 1 : Label = Label_SummaryRoundLeft;
			case 2 : Label = Label_SummaryRoundRight;
		}
		if (Label != Null) Label.SetText(TL::ToText(ML::Max(0, ClanRoundScores[Clan])));
	}
}
***

{{{ManialinkTools::Function("Brightness")}}}
{{{Manialink::Animations(["EaseInCirc", "EaseOutCirc"])}}}

// ---------------------------------- //
// Main
// ---------------------------------- //
main() {
	---Main---
	while (True) {
		yield;
		LibManialink_AnimLoop();
		---Yield---
	}
}
--></script>
</manialink>""";
}

// ---------------------------------- //
/** Create the manialink for the countdown module.
 *
 *	@return		The countdown manialink.
 */
Text Private_CreateManialinkCountdown() {
	return """
<manialink version="2" name="LibInterfancy:Countdown">
<frame id="Frame_Countdown" posn="{{{C_LibInterfancy_CountdownPos.X^" "^C_LibInterfancy_CountdownPos.Y^" "^C_LibInterfancy_CountdownPos.Z}}}">
	<label halign="center" valign="center2" textsize="4" textemboss="1" textcolor="FB0" textfont="Eurostile_Bold" id="Label_Countdown"/>
</frame>

<script><!--
/**
 *	LibInterfancy: Countdown
 */

#Include "MathLib" as ML
#Include "TextLib" as TL

#Const C_CountdownSongsNames 	["Countdown1Compressed.ogg"]
#Const C_CountdownSongDuration	30000

// ---------------------------------- //
// Main
// ---------------------------------- //
***Main***
***
// ---------------------------------- //
// Load interface elements
declare Frame_Countdown <=> (Page.GetFirstChild("Frame_Countdown") as CMlFrame);
declare Label_Countdown <=> (Page.GetFirstChild("Label_Countdown") as CMlLabel);

// ---------------------------------- //
// Netcode
declare netread Integer Net_LibInterfancy_SettingsUpdate for Teams[0];
declare netread Text[Text] Net_LibInterfancy_Settings for Teams[0];

// ---------------------------------- //
// Persistent settings
declare persistent Boolean Persistent_LibInterfancy_DisableCountdownSong for LocalUser;
declare persistent Text[] Persistent_LibInterfancy_TimerMusics for LocalUser;
declare persistent Text Persistent_LibInterfancy_PrevCountdownSong for LocalUser;

// ---------------------------------- //
// Varialbes
declare Countdown_Display = False;
declare Countdown_UseMusic = True;
declare ScoreSummary_Display = False;
declare StartTime = -1;
declare EndTime = -1;
declare CurrentTick = -1;

declare PrevSettingsUpdate = -1;
declare PrevTick = -1;

// ---------------------------------- //
// Countdown soundtrack
declare CAudioSound CountdownMusic;
declare NewMusicName = "";

if (Persistent_LibInterfancy_TimerMusics.count <= 0)
	Persistent_LibInterfancy_TimerMusics = C_CountdownSongsNames;

while (Persistent_LibInterfancy_TimerMusics.count > 0) {
	NewMusicName = Persistent_LibInterfancy_TimerMusics[ML::Rand(0, Persistent_LibInterfancy_TimerMusics.count - 1)];
	if (NewMusicName != Persistent_LibInterfancy_PrevCountdownSong) break;
	if (Persistent_LibInterfancy_TimerMusics.count <= 1) break;
}

if (NewMusicName != "") {
	declare Removed = Persistent_LibInterfancy_TimerMusics.remove(NewMusicName);
	Persistent_LibInterfancy_PrevCountdownSong = NewMusicName;
	CountdownMusic = Audio.CreateSound("{{{C_ImgBase}}}Sounds/"^NewMusicName, 10., True, False, False);
	CountdownMusic.Stop();
}
***

// ---------------------------------- //
// Yield
// ---------------------------------- //
***Yield***
***
// ---------------------------------- //
// Update settings
if (PrevSettingsUpdate != Net_LibInterfancy_SettingsUpdate) {
	PrevSettingsUpdate = Net_LibInterfancy_SettingsUpdate;
	
	foreach (SettingName => SettingValue in Net_LibInterfancy_Settings) {
		switch (SettingName) {
			case "Countdown_Display" : Countdown_Display = SettingValue == "True";
			case "Countdown_UseMusic" : Countdown_UseMusic = SettingValue == "True";
			case "ScoreSummary_Display" : ScoreSummary_Display = SettingValue == "True";
			case "StartTime" : StartTime = TL::ToInteger(SettingValue);
			case "EndTime" : {
				EndTime = TL::ToInteger(SettingValue);
				if (CountdownMusic != Null && GameTime < EndTime - C_CountdownSongDuration) CountdownMusic.Stop();
			}
		}
	}
}

// ---------------------------------- //
// Set visibility
Frame_Countdown.Visible = Countdown_Display && StartTime >= 0;

// ---------------------------------- //
// Display current time
if (Frame_Countdown.Visible) {
	declare Integer Time;
	declare Countdown = True;
	
	// ---------------------------------- //
	// UI.CountdownEndTime is greater than zero
	if (UI.CountdownEndTime > 0 && GameTime < UI.CountdownEndTime) {
		Time = GameTime - UI.CountdownEndTime;
		CurrentTick = ML::Abs(Time) / 1000 + 1;
		if (CurrentTick > 4 || CurrentTick < 1) CurrentTick = -1;
	}
	// ---------------------------------- //
	// EndTime is greater than zero
	else if (EndTime > 0) {
		Time = GameTime - EndTime;
		CurrentTick = (-Time + 1000) / 1000;
		if (CurrentTick > 31 || CurrentTick < -1) CurrentTick = -1;
		Countdown = GameTime < EndTime;
	}
	// ---------------------------------- //
	// Display game duration
	else {
		Time = GameTime - StartTime;
		CurrentTick = -1;
		Countdown = False;
	}
	
	// Set label value
	Label_Countdown.Value = TimeToText(Time, Countdown, ScoreSummary_Display && UseClans);
}

// ---------------------------------- //
// Countdown soundtrack
if (
	Countdown_UseMusic && !Persistent_LibInterfancy_DisableCountdownSong && CountdownMusic != Null &&
	EndTime > 0 && EndTime - GameTime < C_CountdownSongDuration && GameTime < EndTime
) {
	declare NewPlayCursor = (C_CountdownSongDuration - (EndTime - GameTime)) / 1000.;
	
	// ---------------------------------- //
	// Start the music when countdown begins
	if (!CountdownMusic.IsPlaying) {
		CountdownMusic.Play();
		CountdownMusic.PlayCursor = NewPlayCursor;
	}
	
	// Adjust the music play cursor if not matching countdown time
	if (ML::Abs(CountdownMusic.PlayCursor - NewPlayCursor) > .0625) CountdownMusic.PlayCursor = NewPlayCursor;
}

// ---------------------------------- //
// Show animation when last tick changes
if (PrevTick != CurrentTick) {
	PrevTick = CurrentTick;
	declare AnimStartTick = 0;
	
	// ---------------------------------- //
	// Play countdown sounds when the music is not playing
	if (Countdown_UseMusic && UI.CountdownEndTime <= 0 && (CountdownMusic == Null || CountdownMusic.PlayCursor <= 0)) {
		AnimStartTick = 15;
		
		switch (CurrentTick) {
			case 15 : PlayUiSound(::EUISound::Warning, 0, 1.);
			case 1 : Audio.PlaySoundEvent("{{{C_ImgBase}}}/Sounds/UITimeTick_D.wav", -12.5);
			case 0 : PlayUiSound(::EUISound::TimeOut, 1, 1.);
			default : if (CurrentTick < 15) {
				if (CurrentTick > 5) Audio.PlaySoundEvent("{{{C_ImgBase}}}/Sounds/UITimeTick_B.wav", -12.5);
				else Audio.PlaySoundEvent("{{{C_ImgBase}}}/Sounds/UITimeTick_C.wav", -12.5);
			}
		}
	}
	
	// ---------------------------------- //
	// Display tick animation
	if (CurrentTick > 0 && (AnimStartTick == 0 || CurrentTick < AnimStartTick)) {
		LibManialink_AnimStop(Label_Countdown);
		
		Label_Countdown.RelativeScale = 2.;
		Label_Countdown.RelativeRotation = 7.5;
		if (UI.CountdownEndTime > 0) Label_Countdown.TextColor = <0., 1., 0.>;
		else Label_Countdown.TextColor = <1., 0., 0.>;
		
		LibManialink_Anim(Label_Countdown, "<label scale=1 textcolor=FB0 rot=0 />", 1000, "EaseOutCirc");
	}
}
***

// ---------------------------------- //
// Functions
// ---------------------------------- //

// ---------------------------------- //
/** Compose text from given time
 *
 *	@param	_Time		Time to transform
 *	@param	_Decimal	Display decimal part when under minute
 *	@param	_CompactHr	Show campact version of hour time
 *
 *	@return		Composed text
 */
Text TimeToText(Integer _Time, Boolean _Decimal, Boolean _CompactHr) {
	if (_Time == 0) return "0.00";
	declare Time = ML::Abs(_Time);
	
	if (_Decimal && Time < 60000) return Time / 1000^"."^(Time / 100) % 10;
	
	declare Seconds = (Time / 1000) % 60;
	declare Minutes = (Time / 60000) % 60;
	declare Hours = Time / 3600000;
	
	if (_CompactHr && Hours > 0) {
		declare Separator = ":";
		if (Time % 1000 < 500) Separator = " ";
		return Hours^Separator^TL::FormatInteger(Minutes, 2);
	}
	
	if (Hours > 0) return Hours^":"^TL::FormatInteger(Minutes, 2)^":"^TL::FormatInteger(Seconds, 2);
	return Minutes^":"^TL::FormatInteger(Seconds, 2);
}

{{{Manialink::Animations(["EaseOutCirc"])}}}

// ---------------------------------- //
// Main
// ---------------------------------- //
main() {
	+++Main+++
	while (True) {
		+++Yield+++
		LibManialink_AnimLoop();
		yield;
	}
}
--></script>
</manialink>""";
}

// ---------------------------------- //
/** Create the manialink for the spectator information module.
 *
 *	@return		The spectator information manialink.
 */
Text Private_CreateManialinkSpecInfo() {
	return """
<manialink version="2" name="LibInterfancy:SpecInfo">
<stylesheet>
	<style id="Label_PlayerName" textemboss="1" textsize="3" textcolor="FFF" textfont="Eurostile"/>
	<style id="Label_PlayerZone" textemboss="1" textsize="2" textcolor="FFF" textfont="Eurostile_Bold" textprefix="$t"/>
</stylesheet>

<frame id="Frame_SpectatorInfo" posn="{{{C_LibInterfancy_SpecInfoPos.X^" "^C_LibInterfancy_SpecInfoPos.Y^" "^C_LibInterfancy_SpecInfoPos.Z}}}" hidden="1">
	<label posn="0 3.25" halign="center" valign="center2" id="Label_PlayerName"/>
	<quad sizen="54 3.5" halign="center" valign="center" image="{{{C_ImgBase}}}ColorSeparator.png" id="Quad_PlayerColor"/>
	<frame posn="0 -3" id="Frame_PlayerZone">
		<quad sizen="4 4" valign="center" id="Quad_PlayerZone"/>
		<label valign="center2" id="Label_PlayerZone"/>
	</frame>
</frame>

<script><!--
/**
 *	LibInterfancy: SpecInfo
 */

#Include "MathLib" as ML
#Include "TextLib" as TL

// ---------------------------------- //
// Main
// ---------------------------------- //
***Main***
***
// ---------------------------------- //
// Load interface elements
declare Frame_SpectatorInfo <=> (Page.GetFirstChild("Frame_SpectatorInfo") as CMlFrame);
declare Label_PlayerName <=> (Page.GetFirstChild("Label_PlayerName") as CMlLabel);
declare Quad_PlayerColor <=> (Page.GetFirstChild("Quad_PlayerColor") as CMlQuad);
declare Frame_PlayerZone <=> (Page.GetFirstChild("Frame_PlayerZone") as CMlFrame);
declare Quad_PlayerZone <=> (Page.GetFirstChild("Quad_PlayerZone") as CMlQuad);
declare Label_PlayerZone <=> (Page.GetFirstChild("Label_PlayerZone") as CMlLabel);

// ---------------------------------- //
// Netcode
declare netread Integer Net_LibInterfancy_SettingsUpdate for Teams[0];
declare netread Text[Text] Net_LibInterfancy_Settings for Teams[0];

/// Players colors
declare netread Vec3[Text] Net_LibInterfancy_ForcedColors for Teams[0];

// ---------------------------------- //
// Variables
declare SpecInfo_Display = True;

/// Update
declare PrevSettingsUpdate = -1;
declare PrevGUIPlayerLogin = "";
declare PrevGUIPlayerClan = -1;
declare PrevTeamsColors = [0 => Vec3, 1 => Vec3];
***

// ---------------------------------- //
// Yield
// ---------------------------------- //
***Yield***
***
// ---------------------------------- //
// Update settings
if (PrevSettingsUpdate != Net_LibInterfancy_SettingsUpdate) {
	PrevSettingsUpdate = Net_LibInterfancy_SettingsUpdate;
	
	foreach (SettingName => SettingValue in Net_LibInterfancy_Settings) {
		switch (SettingName) {
			case "SpecInfo_Display" : SpecInfo_Display = SettingValue == "True";
		}
	}
}

// ---------------------------------- //
// Set spectator information visibility
Frame_SpectatorInfo.Visible = SpecInfo_Display && GUIPlayer != Null && GUIPlayer.User != LocalUser && GUIPlayer.Position != <0., 0., 0.>;
if (!Frame_SpectatorInfo.Visible) continue;

// ---------------------------------- //
// Update on player clan change
if (PrevGUIPlayerClan != GUIPlayer.CurrentClan) {
	PrevGUIPlayerClan = GUIPlayer.CurrentClan;
	PrevGUIPlayerLogin = "";
}

// ---------------------------------- //
// Update on team color change
for (I, 0, 1) if (PrevTeamsColors[I] != Teams[I].ColorPrimary) {
	PrevTeamsColors[I] = Teams[I].ColorPrimary;
	if (I == GUIPlayer.CurrentClan - 1) PrevGUIPlayerLogin = "";
}

// ---------------------------------- //
// Update player information
if (PrevGUIPlayerLogin != GUIPlayer.User.Login) {
	PrevGUIPlayerLogin = GUIPlayer.User.Login;
	
	// ---------------------------------- //
	// Update name
	declare PlayerName = GUIPlayer.User.Login;
	if (TL::Length(TL::StripFormatting(GUIPlayer.User.Name)) > 3) PlayerName = GUIPlayer.User.Name;
	Label_PlayerName.SetText(PlayerName);
	
	// ---------------------------------- //
	// Update colour
	declare Color = GUIPlayer.User.Color;
	
	// Use the player clan colour
	if (GUIPlayer.CurrentClan > 0) Color = Teams[GUIPlayer.CurrentClan - 1].ColorPrimary;
	
	// Use forced colour
	else if (Net_LibInterfancy_ForcedColors.existskey(GUIPlayer.User.Login))
		Color = Net_LibInterfancy_ForcedColors[GUIPlayer.User.Login];
	
	Quad_PlayerColor.Colorize = Color;
	
	// ---------------------------------- //
	// Update zone name
	declare ZoneName = "World";
	declare ZonePath = TL::Split("|", GUIPlayer.User.ZonePath);
	if (ZonePath.count > 0) ZoneName = ZonePath[ML::Min(2, ZonePath.count - 1)];
	if (GUIPlayer.User.IsFakeUser) ZoneName = "Bot";
	
	// ---------------------------------- //
	// Update zone icon
	if (ZonePath.count > 2) Quad_PlayerZone.ImageUrl = GUIPlayer.User.CountryFlagUrl;
	else Quad_PlayerZone.ImageUrl = GUIPlayer.User.LadderZoneFlagUrl;
	
	// ---------------------------------- //
	// Update position
	Label_PlayerZone.SetText(ZoneName);
	Label_PlayerZone.RelativePosition.X = Quad_PlayerZone.Size.X + .5;
	Frame_PlayerZone.RelativePosition.X = -(Label_PlayerZone.RelativePosition.X + ComputeWidth(Label_PlayerZone)) / 2;
}
***

// ---------------------------------- //
// Functions
// ---------------------------------- //

{{{ManialinkTools::Function("ComputeWidth")}}}

// ---------------------------------- //
// Main
// ---------------------------------- //
main() {
	+++Main+++
	while (True) {
		yield;
		+++Yield+++
	}
}
--></script>
</manialink>""";
}

// ---------------------------------- //
/** Create the manialink for the crosshair module.
 *
 *	@return		The crosshair manialink.
 */
Text Private_CreateManialinkCrosshair() {
	return """
<manialink version="2" name="LibInterfancy:Crosshair">
<stylesheet>
	<style class="MissMessage" halign="center" valign="center2" textemboss="1" textsize="2" textcolor="FFF" textfont="Eurostile_Bold"/>
	<style class="ch" halign="center" valign="center"/>
</stylesheet>

<frame id="Frame_Crosshair" posn="{{{C_LibInterfancy_CrosshairPos.X^" "^C_LibInterfancy_CrosshairPos.Y^" "^C_LibInterfancy_CrosshairPos.Z}}}" hidden="1">
	<quad sizen="1 1" halign="center" valign="center" image="{{{C_ImgBase}}}Crosshair/Dot.png" id="Quad_CrosshairDot"/>
	<frame id="Frame_CrosshairAnim">
		<quad sizen="16 16" class="ch" image="{{{C_ImgBase}}}Crosshair/Rocket.png" id="Quad_CrosshairRocket"/>
		<quad sizen="16 16" class="ch" image="{{{C_ImgBase}}}Crosshair/Laser.png" id="Quad_CrosshairLaser"/>
		<quad sizen="16 16" class="ch" image="{{{C_ImgBase}}}Crosshair/Nucleus.png" id="Quad_CrosshairNucleus"/>
		<quad sizen="12 48" halign="center" image="{{{C_ImgBase}}}Crosshair/Arrow.png" id="Quad_CrosshairArrow"/>
	</frame>
	<frame id="Frame_CrosshairGauge" hidden="1">
		<frame clip="1" clipposn="8" clipsizen="16 32">
			<quad posn="-.2" sizen="28 28" class="ch" image="{{{C_ImgBase}}}Crosshair/Gauge.png" id="Quad_GaugeRight"/>
		</frame>
		<frame clip="1" clipposn="-8" clipsizen="16 32">
			<quad posn=".2" sizen="28 28" class="ch" image="{{{C_ImgBase}}}Crosshair/Gauge.png" id="Quad_GaugeLeft"/>
		</frame>
	</frame>
</frame>

<frame id="Frame_NearMissMessage" posn="{{{C_LibInterfancy_NearMissMsgPos.X^" "^C_LibInterfancy_NearMissMsgPos.Y^" "^C_LibInterfancy_NearMissMsgPos.Z}}}">
	<label class="MissMessage" id="Label_NearMissMessage"/>
	<label class="MissMessage" id="Label_NearMissGhost"/>
</frame>

<script><!--
/**
 *	LibInterfancy: Crosshair
 */

#Include "MathLib" as ML
#Include "TextLib" as TL

#Const C_NearMissDisplayTime	{{{C_LibInterfancy_NearMissDisplayTime}}}
#Const C_OpacityFadeLimit		.125

// ---------------------------------- //
// Main
// ---------------------------------- //
***Main***
***
// ---------------------------------- //
// Load interface elements
declare Frame_Crosshair			<=> (Page.GetFirstChild("Frame_Crosshair") as CMlFrame);
declare Frame_CrosshairAnim		<=> (Page.GetFirstChild("Frame_CrosshairAnim") as CMlFrame);

declare Quad_CrosshairDot		<=> (Page.GetFirstChild("Quad_CrosshairDot") as CMlQuad);
declare Quad_CrosshairLaser		<=> (Page.GetFirstChild("Quad_CrosshairLaser") as CMlQuad);
declare Quad_CrosshairRocket	<=> (Page.GetFirstChild("Quad_CrosshairRocket") as CMlQuad);
declare Quad_CrosshairNucleus	<=> (Page.GetFirstChild("Quad_CrosshairNucleus") as CMlQuad);
declare Quad_CrosshairArrow		<=> (Page.GetFirstChild("Quad_CrosshairArrow") as CMlQuad);

declare Frame_CrosshairGauge	<=> (Page.GetFirstChild("Frame_CrosshairGauge") as CMlFrame);
declare Quad_GaugeRight	<=> (Page.GetFirstChild("Quad_GaugeRight") as CMlQuad);
declare Quad_GaugeLeft	<=> (Page.GetFirstChild("Quad_GaugeLeft") as CMlQuad);

declare Label_NearMissMessage	<=> (Page.GetFirstChild("Label_NearMissMessage") as CMlLabel);
declare Label_NearMissGhost		<=> (Page.GetFirstChild("Label_NearMissGhost") as CMlLabel);

// ---------------------------------- //
// Persistent settings
declare persistent Persistent_LibInterfancy_UseCustomCrosshair for LocalUser = True;

// ---------------------------------- //
// Netcode
declare netread Integer Net_LibInterfancy_SettingsUpdate for Teams[0];
declare netread Text[Text] Net_LibInterfancy_Settings for Teams[0];
declare netread Text[][Text] Net_LibInterfancy_CrosshairNote for Teams[0];
declare netread Integer[Text] Net_LibInterfancy_CrosshairNoteTime for Teams[0];

// ---------------------------------- //
// Variables
declare Crosshair_Display = True;
declare AnimateCrosshair = False;
declare UpdateNote = True;
declare CrosshairNote = "";
declare CrosshairNoteTime = -1;
declare SpawnInvulnerabilityDuration = 2000;

declare PrevGUIPlayerLogin = "";
declare PrevAmmoCount = 0;
declare PrevCurWeapon = 0;
declare PrevCrosshairNote = "";
declare PrevCrosshairNoteTime = -1;
declare PrevSettingsUpdate = -1;
***

// ---------------------------------- //
// Yield
// ---------------------------------- //
***Yield***
***
// ---------------------------------- //
// Manage events
foreach (Event in PendingEvents) {
	if (Event.Type == CMlEvent::Type::KeyPress) {
		if (Event.KeyName == "B") Persistent_LibInterfancy_UseCustomCrosshair = !Persistent_LibInterfancy_UseCustomCrosshair;
	}
}

// ---------------------------------- //
// Update settings
if (PrevSettingsUpdate != Net_LibInterfancy_SettingsUpdate) {
	PrevSettingsUpdate = Net_LibInterfancy_SettingsUpdate;
	
	foreach (SettingName => SettingValue in Net_LibInterfancy_Settings) {
		switch (SettingName) {
			case "SpawnInvulnerabilityDuration" : SpawnInvulnerabilityDuration = TL::ToInteger(SettingValue);
		}
	}
}

// ---------------------------------- //
// Set crosshair visibility
ClientUI.OverlayHideCrosshair = !Crosshair_Display || Persistent_LibInterfancy_UseCustomCrosshair;
Frame_Crosshair.Visible =
	ClientUI.OverlayHideCrosshair && GUIPlayer != Null && !GUIPlayer.IsOnTechNoWeapon && !GUIPlayer.IsInWater &&
	GUIPlayer.Position != <0., 0., 0.> && GameTime >= GUIPlayer.StartTime - 1500 &&
	GUIPlayer.CurAmmoMax > 0 && GUIPlayer.CurAmmoUnit > 0;

// ---------------------------------- //
// Update GUIPlayer
if (GUIPlayer != Null && PrevGUIPlayerLogin != GUIPlayer.User.Login) {
	PrevGUIPlayerLogin = GUIPlayer.User.Login;
	PrevAmmoCount = 0;
	PrevCurWeapon = 0;
}

// ---------------------------------- //
// Manage crosshair
if (Frame_Crosshair.Visible) {
	Quad_CrosshairDot.Visible = GUIPlayer.CurWeapon != 5;
	Frame_CrosshairGauge.Visible = GUIPlayer.CurAmmo < GUIPlayer.CurAmmoUnit || GameTime - GUIPlayer.StartTime < SpawnInvulnerabilityDuration;
	
	Quad_CrosshairLaser.Visible = GUIPlayer.CurWeapon == 1;
	Quad_CrosshairRocket.Visible = GUIPlayer.CurWeapon == 2;
	Quad_CrosshairNucleus.Visible = GUIPlayer.CurWeapon == 3;
	Quad_CrosshairArrow.Visible = GUIPlayer.CurWeapon == 5;
	
	// ---------------------------------- //
	// Trigger animation on weapon change
	if (PrevCurWeapon != GUIPlayer.CurWeapon) {
		if (PrevCurWeapon > 0) AnimateCrosshair = True;
		PrevCurWeapon = GUIPlayer.CurWeapon;
	}
	
	// ---------------------------------- //
	// Trigger animation on shoot
	if (PrevAmmoCount != GUIPlayer.CurAmmo) {
		if (PrevAmmoCount > 0 && PrevAmmoCount > GUIPlayer.CurAmmo) AnimateCrosshair = True;
		PrevAmmoCount = GUIPlayer.CurAmmo;
	}
	
	// ---------------------------------- //
	// Display Gauge
	if (Frame_CrosshairGauge.Visible) {
		declare Ratio = ML::ToReal(GUIPlayer.CurAmmo) / GUIPlayer.CurAmmoUnit;
		if (GameTime - GUIPlayer.StartTime < 2000) Ratio = ML::ToReal(GameTime - GUIPlayer.StartTime) / SpawnInvulnerabilityDuration;
		
		Quad_GaugeRight.RelativeRotation = ML::Clamp(Ratio, 0., .5) * 360 - 180;
		Quad_GaugeLeft.RelativeRotation = ML::Clamp(Ratio, .5, 1.) * 360 - 180;
		
		Quad_GaugeRight.Opacity = ML::Min(1 - Ratio, C_OpacityFadeLimit) / C_OpacityFadeLimit;
		Quad_GaugeLeft.Opacity = Quad_GaugeRight.Opacity;
		
		Quad_CrosshairLaser.Opacity = 1. - Quad_GaugeRight.Opacity;
		Quad_CrosshairRocket.Opacity = Quad_CrosshairLaser.Opacity;
		Quad_CrosshairNucleus.Opacity = Quad_CrosshairLaser.Opacity;
		Quad_CrosshairArrow.Opacity = Quad_CrosshairLaser.Opacity;
	}
	// ---------------------------------- //
	// Reset opacity
	else {
		Quad_CrosshairLaser.Opacity = 1.;
		Quad_CrosshairRocket.Opacity = 1.;
		Quad_CrosshairNucleus.Opacity = 1.;
		Quad_CrosshairArrow.Opacity = 1.;
	}
}

// ---------------------------------- //
// Animate crosshair
if (AnimateCrosshair) {
	AnimateCrosshair = False;
	LibManialink_AnimStop(Frame_CrosshairAnim);
	Frame_CrosshairAnim.RelativeScale = 2.5;
	LibManialink_Anim(Frame_CrosshairAnim, "<frame scale=1 />", 750, "EaseOutCirc");
}

// ---------------------------------- //
// Update note on GUIPlayer change
if (GUIPlayer != Null) {
	if (PrevGUIPlayerLogin != GUIPlayer.User.Login) {
		PrevGUIPlayerLogin = GUIPlayer.User.Login;
		UpdateNote = True;
	}
} else if (PrevGUIPlayerLogin != "") {
	PrevGUIPlayerLogin = "";
	UpdateNote = True;
}

// ---------------------------------- //
// Get the current player crosshair note end time
if (GUIPlayer != Null && Net_LibInterfancy_CrosshairNoteTime.existskey(GUIPlayer.User.Login)) {
	if (GameTime < Net_LibInterfancy_CrosshairNoteTime[GUIPlayer.User.Login]) {
		CrosshairNoteTime = Net_LibInterfancy_CrosshairNoteTime[GUIPlayer.User.Login];
	} else CrosshairNoteTime = -1;
} else CrosshairNoteTime = -1;

// ---------------------------------- //
// Update on time change
if (PrevCrosshairNoteTime != CrosshairNoteTime) {
	PrevCrosshairNoteTime = CrosshairNoteTime;
	UpdateNote = True;
}

// ---------------------------------- //
// Update note text
if (UpdateNote) {
	UpdateNote = False;
	if (PrevCrosshairNoteTime > 0 && Net_LibInterfancy_CrosshairNote.existskey(GUIPlayer.User.Login))
		CrosshairNote = TL::GetTranslatedText(Translate(Net_LibInterfancy_CrosshairNote[GUIPlayer.User.Login]));
	else
		CrosshairNote = "";
}

// ---------------------------------- //
// Update near miss message
if (PrevCrosshairNote != CrosshairNote) {
	PrevCrosshairNote = CrosshairNote;
	Label_NearMissGhost.SetText(Label_NearMissMessage.Value);
	Label_NearMissMessage.SetText(CrosshairNote);
	
	LibManialink_AnimStop(Label_NearMissMessage);
	LibManialink_AnimStop(Label_NearMissGhost);
	
	Label_NearMissMessage.Opacity = 0.;
	Label_NearMissGhost.Opacity = 1.;
	Label_NearMissMessage.RelativePosition.Y = 2.;
	Label_NearMissGhost.RelativePosition.Y = 0.;
	
	LibManialink_Anim(Label_NearMissMessage, "<label posn='0 0' opacity=1 />", 125, "EaseLinear");
	LibManialink_Anim(Label_NearMissGhost, "<label posn='0 -2' opacity=0 />", 125, "EaseLinear");
}

Label_NearMissMessage.Visible = Label_NearMissMessage.Opacity > 0;
Label_NearMissGhost.Visible = Label_NearMissGhost.Opacity > 0;
***

{{{Manialink::Animations(["EaseLinear", "EaseOutCirc"])}}}
{{{Translations::InjectInManialink(["%1 miss", "$<%1$> healed you!", "Healed %1 players", "Healed 1 player", "$<%1$> boosted you!", "Boosted %1 players", "Boosted 1 player", "Laser", "Nucleus", "Arrow", "Rocket", "Skills"])}}}

// ---------------------------------- //
// Main
// ---------------------------------- //
main() {
	+++Main+++
	while (True) {
		+++Yield+++
		LibManialink_AnimLoop();
		yield;
	}
}
--></script>
</manialink>""";
}

// ---------------------------------- //
// Public
// ---------------------------------- //

// ---------------------------------- //
/** Return the version number of the script.
 *
 *	@return		The version number of the script.
 */
Text GetScriptVersion() { return Version; }

// ---------------------------------- //
/** Return the name of the script.
 *
 *	@return		The name of the script.
 */
Text GetScriptName() { return ScriptName; }

// ---------------------------------- //
/** Set visibility of a module.
 *
 *	@param	_ModuleName		Name of the module to set visibilty.
 *	@param	_Visible		If True, the module will be visible.
 */
Void SetModuleVisibility(Text _ModuleName, Boolean _Visible) {
	if (Private_ModuleIsLoaded(_ModuleName)) {
		switch (_ModuleName) {
			case "Gauges"		: UIManager.UIAll.OverlayHideGauges = True;
			case "Countdown"	: UIManager.UIAll.OverlayHideCountdown = True;
			case "SpecInfo"		: UIManager.UIAll.OverlayHideSpectatorInfos = True;
			case "321Go"		: UIManager.UIAll.OverlayHide321Go = True;
		}
	} else {
		switch (_ModuleName) {
			case "Gauges"		: UIManager.UIAll.OverlayHideGauges = !_Visible;
			case "Countdown"	: UIManager.UIAll.OverlayHideCountdown = !_Visible;
			case "SpecInfo"		: UIManager.UIAll.OverlayHideSpectatorInfos = !_Visible;
			case "Crosshair"	: UIManager.UIAll.OverlayHideCrosshair = !_Visible;
			case "321Go"		: UIManager.UIAll.OverlayHide321Go = !_Visible;
		}
	}
	G_LibInterfancy_ModuleVisibility[_ModuleName] = _Visible;
	Private_SetModuleSetting(_ModuleName^"_Display", TL::ToText(_Visible));
}

// ---------------------------------- //
/** Get visibility of a module.
 *
 *	@param	_ModuleName		Name of the module to get its visibility.
 *
 *	@return		True when the module is visible, False otherwise.
 */
Boolean GetModuleVisibility(Text _ModuleName) {
	if (Private_ModuleIsLoaded(_ModuleName) && G_LibInterfancy_ModuleVisibility.existskey(_ModuleName))
		return G_LibInterfancy_ModuleVisibility[_ModuleName];
	
	switch (_ModuleName) {
		case "Countdown"	: return !UIManager.UIAll.OverlayHideCountdown;
		case "SpecInfo"		: return !UIManager.UIAll.OverlayHideSpectatorInfos;
		case "Crosshair"	: return !UIManager.UIAll.OverlayHideCrosshair;
		case "321Go"		: return !UIManager.UIAll.OverlayHide321Go;
	}
	return False;
}

// ---------------------------------- //
/** Load new or replace existing icons in the gauges module.
 *	You can load custom weapons icons, they will appear when
 *	player has custom weapon name specified and icon with such
 *	name has been set.
 *
 *	@param	_IconsImages	Array of gauges icons keyed by their names. Images can be both links
 *							to icons files or an existing game style in format "Style|Substyle".
 */
Void SetGaugesIconsImages(Text[Text] _IconsImages) {
	if (_IconsImages.count <= 0) return;
	foreach (Icon => Image in _IconsImages) Private_SetModuleSetting("Gauges_Icon"^Icon, Image);
}

// ---------------------------------- //
/** Set visibility of the round points in scores summary.
 *
 *	@param	_Visible	If True, round points will be seen aside of the normal points.
 */
Void SetRoundPointsVisibility(Boolean _Visible) {
	Private_SetModuleSetting("ScoreSummary_ShowRoundPoints", TL::ToText(_Visible));
}

// ---------------------------------- //
/** Display a notice under player's crosshair.
 *
 *	@param	_Player		The player to display crosshair notice.
 *	@param	_Message	Array of message elements to by the client, first one being the base of the message.
 *	@param	_Duration	Display duration of the crosshair notice.
 */
Void SendCrosshairNote(CSmPlayer _Player, Text[] _Message, Integer _Duration) {
	if (_Player == Null || _Player.IsBot || _Player.IsFakePlayer || _Message.count <= 0 || _Message[0] == "") return;
	
	declare netwrite Text[][Text] Net_LibInterfancy_CrosshairNote for Teams[0];
	declare netwrite Integer[Text] Net_LibInterfancy_CrosshairNoteTime for Teams[0];
	
	Net_LibInterfancy_CrosshairNote[_Player.User.Login] = _Message;
	Net_LibInterfancy_CrosshairNoteTime[_Player.User.Login] = Now + _Duration;
}

// ---------------------------------- //
/** Display near miss notice under player's crosshair.
 *
 *	@param	_Player		The player to display near miss notice.
 *	@param	_Distance	Distance of the near miss event.
 */
Void DisplayNearMiss(CSmPlayer _Player, Real _Distance) {
	if (_Player == Null || _Player.IsBot || _Player.IsFakePlayer || _Distance <= 0 || _Distance > 1) return;
	
	// ---------------------------------- //
	// Get the distance text
	declare Text DistanceText;
	if (_Distance > 0 && _Distance < 1) {
		if (_Distance >= 0.01)
			DistanceText = ML::FloorInteger(_Distance * 100)^"cm";
		else if (_Distance >= 0.001)
			DistanceText = ML::FloorInteger(_Distance * 1000)^"mm";
		else
			DistanceText = ML::FloorInteger(_Distance * 1000000)^"m";
	}
	
	// Send note
	SendCrosshairNote(_Player, ["%1 miss", DistanceText], C_LibInterfancy_NearMissDisplayTime);
}

// ---------------------------------- //
/** Update player's reload speed boost information.
 *
 *	@param	_Player			The player to update boost information.
 *	@param	_StartTime		Reload speed boost start time.
 *	@param	_Duration		Duration of the reload speed boost.
 */
Void SetPlayerReloadData(CSmPlayer _Player, Integer _StartTime, Integer _Duration) {
	if (_Player == Null) return;
	declare netwrite Int3[Text] Net_LibInterfancy_ReloadData for Teams[0];
	Net_LibInterfancy_ReloadData[_Player.User.Login] = <_StartTime, _Duration, 0>;
}

// ---------------------------------- //
/** Change player's interface and character color.
 *
 *	@param	_Player		The player to set color.
 *	@param	_Color		Color to apply to the player.
 */
Void ForceColor(CSmPlayer _Player, Vec3 _Color) {
	if (_Player == Null) return;
	declare netwrite Vec3[Text] Net_LibInterfancy_ForcedColors for Teams[0];
	
	// Set player forced color
	if (_Color != <-1., -1., -1.>) {
		declare Color = _Color;
		for (I, 0, 2) Color[I] = ML::Clamp(Color[I], 0., 1.);
		Net_LibInterfancy_ForcedColors[_Player.User.Login] = Color;
		_Player.ForceColor = Color;
	}
	
	// Reset forced color
	else {
		declare Removed = Net_LibInterfancy_ForcedColors.removekey(_Player.User.Login);
		_Player.ForceColor = <-1., -1., -1.>;
	}
}

// ---------------------------------- //
/** Reset custom color of a player.
 *
 *	@param	_Player		The player to reset custom forced color.
 */
Void ResetColor(CSmPlayer _Player) {
	ForceColor(_Player, <-1., -1., -1.>);
}

// ---------------------------------- //
/** Change the name of weapon currently worn by a player.
 *
 *	@param	_Player		The player to change current weapon name.
 *	@param	_Name		The custom name of weapon to set.
 */
Void SetPlayerCustomWeapon(CSmPlayer _Player, Text _Name) {
	if (_Player == Null || _Player.IsBot) return;
	declare netwrite Text[Text] Net_LibInterfancy_PlayersWeaponsNames for Teams[0];
	
	// Set custom name
	if (_Name != "") Net_LibInterfancy_PlayersWeaponsNames[_Player.User.Login] = _Name;
	
	// Remove custom name
	else if (Net_LibInterfancy_PlayersWeaponsNames.existskey(_Player.User.Login)) {
		declare Removed = Net_LibInterfancy_PlayersWeaponsNames.removekey(_Player.User.Login);
	}
}

// ---------------------------------- //
/** Set spawn invulnerability duration.
 *
 *	@param	_Duration	Time for how long all players are unable to interact with otherss after being spawned.
 */
Void SetSpawnInvulnerabilityDuration(Integer _Duration) {
	SpawnInvulnerabilityDuration = _Duration;
	Private_SetModuleSetting("SpawnInvulnerabilityDuration", TL::ToText(_Duration));
}

// ---------------------------------- //
/** Set new value for the end time (visuals only).
 *
 *	@param	_NewEndTime		The new end time to set.
 */
Void SetEndTime(Integer _NewEndTime) {
	declare NewEndTime = ML::Max(_NewEndTime, -1);
	Private_SetModuleSetting("EndTime", TL::ToText(NewEndTime));
}

// ---------------------------------- //
/** Set if the countdown module should play the countdown soundtrack.
 *
 *	@param	_UseMusic	If True, special music during the countdown will be played.
 */
Void SetUseMusic(Boolean _UseMusic) {
	Private_SetModuleSetting("Countdown_UseMusic", TL::ToText(_UseMusic));
}

// ---------------------------------- //
/// Reset all data sent through network by the library.
Void ClearData() {
	declare netwrite Text[][Text] Net_LibInterfancy_CrosshairNote for Teams[0];
	declare netwrite Integer[Text] Net_LibInterfancy_CrosshairNoteTime for Teams[0];
	declare netwrite Int3[Text] Net_LibInterfancy_ReloadData for Teams[0];
	declare netwrite Vec3[Text] Net_LibInterfancy_ForcedColors for Teams[0];
	declare netwrite Text[Text] Net_LibInterfancy_PlayersWeaponsNames for Teams[0];
	
	Net_LibInterfancy_CrosshairNote.clear();
	Net_LibInterfancy_CrosshairNoteTime.clear();
	Net_LibInterfancy_ReloadData.clear();
	Net_LibInterfancy_ForcedColors.clear();
	Net_LibInterfancy_PlayersWeaponsNames.clear();
}

// ---------------------------------- //
/** Load a module by its name.
 *
 *	@param	_ModuleId	Name of the module to load.
 */
Void LoadModule(Text _ModuleId) {
	if (Private_ModuleIsLoaded(_ModuleId)) return;
	G_LibInterfancy_ModulesLoaded.add(_ModuleId);
	
	switch (_ModuleId) {
		case "Gauges"		: Layers::Create(_ModuleId, Private_CreateManialinkGauges());
		case "ScoreSummary"	: Layers::Create(_ModuleId, Private_CreateManialinkScoreSummary());
		case "Countdown"	: Layers::Create(_ModuleId, Private_CreateManialinkCountdown());
		case "SpecInfo"		: Layers::Create(_ModuleId, Private_CreateManialinkSpecInfo());
		case "Crosshair"	: Layers::Create(_ModuleId, Private_CreateManialinkCrosshair());
	}
	
	Layers::Attach(_ModuleId);
	SetModuleVisibility(_ModuleId, True);
}

// ---------------------------------- //
/** Load several modules by their names.
 *
 *	@param	_ModulesIds		An array with names of modules to load with the library.
 */
Void LoadModules(Text[] _ModulesIds) { foreach (ModuleId in _ModulesIds) LoadModule(ModuleId); }

// ---------------------------------- //
/** Unload a module by its name.
 *
 *	@param	_ModuleId		Name of the module to unload.
 */
Void UnloadModule(Text _ModuleId) {
	declare Removed = G_LibInterfancy_ModulesLoaded.remove(_ModuleId);
	if (Removed) {
		// Remove module layer
		Layers::Detach(_ModuleId);
		Layers::Destroy(_ModuleId);
		SetModuleVisibility(_ModuleId, True);
	}
}

// ---------------------------------- //
/// Unload the library.
Void Unload() {
	foreach (ModuleId in G_LibInterfancy_ModulesLoaded) UnloadModule(ModuleId);
	ClearData();	
	
	declare netwrite Net_LibInterfancy_SettingsUpdate for Teams[0] = 0;
	declare netwrite Net_LibInterfancy_Settings for Teams[0] = Text[Text];
	Net_LibInterfancy_SettingsUpdate = 0;
	Net_LibInterfancy_Settings.clear();
	
	G_LibInterfancy_ModulesLoaded.clear();
	G_LibInterfancy_ModuleVisibility.clear();
	G_LibInterfancy_PrevStartTime = -1;
	G_LibInterfancy_PrevEndTime = -1;
}

// ---------------------------------- //
/// Load the library.
Void Load() { Unload(); }

// ---------------------------------- //
/** (Overload) Load the library with some modules.
 *
 *	@param	_AutoLoadModules	A list of modules to load with the library.
 */
Void Load(Text[] _AutoLoadModules) {
	Load();
	LoadModules(_AutoLoadModules);
}

// ---------------------------------- //
/** Loop containing functions erasing unnecessary data and automatically updating the game start and end time.
 *
 *	@param	_UseDefaultEndTime		Wherher the library should use the default end time value.
 */
Void Loop(Boolean _UseDefaultEndTime) {
	// ---------------------------------- //
	// Update Start and End time in Countdown module
	if (G_LibInterfancy_PrevStartTime != StartTime) {
		G_LibInterfancy_PrevStartTime = StartTime;
		Private_SetModuleSetting("StartTime", TL::ToText(StartTime));
	}
	if (_UseDefaultEndTime && G_LibInterfancy_PrevEndTime != EndTime) {
		G_LibInterfancy_PrevEndTime = EndTime;
		Private_SetModuleSetting("EndTime", TL::ToText(EndTime));
	}
	
	if (Now < G_LibInterfancy_NextUICleaningTime) return;
	G_LibInterfancy_NextUICleaningTime = Now + C_LibInterfancy_UICleaningPeriod;
	
	// ---------------------------------- //
	// Remove no longer visible crosshair notes
	declare netwrite Integer[Text] Net_LibInterfancy_CrosshairNoteTime for Teams[0];
	
	declare Text[] LoginsToRemove;
	foreach (Login => EndTime in Net_LibInterfancy_CrosshairNoteTime) if (Now >= EndTime) LoginsToRemove.add(Login);
	
	if (LoginsToRemove.count > 0) {
		declare netwrite Text[][Text] Net_LibInterfancy_CrosshairNote for Teams[0];
		foreach (Login in LoginsToRemove) {
			declare Boolean Tmp;
			Tmp = Net_LibInterfancy_CrosshairNote.removekey(Login);
			Tmp = Net_LibInterfancy_CrosshairNoteTime.removekey(Login);
		}
	}
	
	// ---------------------------------- //
	// Remove no longer needed reload boost data
	declare netwrite Int3[Text] Net_LibInterfancy_ReloadData for Teams[0];
	
	if (LoginsToRemove.count > 0) LoginsToRemove.clear();
	foreach (Login => Data in Net_LibInterfancy_ReloadData)
		if (Now >= Data[0] + Data[1]) LoginsToRemove.add(Login);
	
	foreach (Login in LoginsToRemove) {
		declare Tmp = Net_LibInterfancy_ReloadData.removekey(Login);
	}
}

// ---------------------------------- //
/// Loop without using the system end time.
Void Loop() { Loop(False); }